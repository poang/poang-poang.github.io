# 异常 

## 异常概念

指程序运行中，出现的非正常的情况，最终导致JVM的非正常停止。

 ## 异常体系结构

异常机制其实是帮助我们**找到**程序中的问题，异常的根类是`java.lang.Throwable`，其下有两个子类：`java.lang.Error`与`java.lang.Exception`，平常所说的异常指`java.lang.Exception`。

![image-20220315183255010](https://poangspic.oss-cn-beijing.aliyuncs.com/img/image-20220315183255010.png)

 java.lang.Throwable
 		|-----java.lang.Error:一般不编写针对性的代码进行处理。
 		|-----java.lang.Exception:可以进行异常的处理
 			|------编译时异常(checked)
 					|-----IOException
 					|-----FileNotFoundException
 					|-----ClassNotFoundException
 			|------运行时异常(unchecked,RuntimeException)
 					|-----NullPointerException
 					|-----ArrayIndexOutOfBoundsException
 					|-----ClassCastException
 					|-----NumberFormatException
 					|-----InputMismatchException
 					|-----ArithmeticException

## 异常分类

**异常(Exception)的分类**:根据在编译时期还是运行时期去检查异常?

* **编译时期异常**:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)
* **运行时期异常**:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)

### 异常处理：抓抛模型

-  过程一：
   "抛"：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。 并将此对象抛出。  一旦抛出对象以后，其后的代码就不再执行。
   	

关于异常对象的产生：
	1.  系统自动生成的异常对象
	2.  手动的生成一个异常对象，并抛出（throw）

- 过程二："抓"：可以理解为异常的处理方式：

   1. try-catch-finally 

   2. throws

      说明： 

        1. finally是可选的；即使catch中又出现了异常，try中有return语句，finally也一定会被执行
           应用：数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，需要手动自愿释放，需要声明在finally中
        2. 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配
        3. 一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没有写finally的情况）。继续执行其后的代码
        4. catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。 catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错
        5. 常用的异常对象处理的方式： 
           - String  getMessage()    
           - printStackTrace()
        6. 在try结构中声明的变量，再出了try结构以后，就不能再被调用
        7. try-catch-finally结构可以嵌套

 ### 异常处理的的方式二：throws +异常类型

  1. “throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后的异常类型时，异常抛出。异常代码后续的代码不再执行。
  2. try-catch-finally：真正的将异常给处理掉了。
     throws的方式只是将异常抛给了方法的调用者，并没有真正将异常处理掉。
  3. 开发中如何选择使用try-catch-finally 还是使用throws？
     3.1 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。
     3.2 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。

### 用户自己定义异常类

1. 继承于现有的异常结构：RuntimeException 、Exception
2. 提供全局常量：serialVersionUID
3. 提供重载的构造器

```java
public class LoginException extends Exception {
    /**
     * 空参构造
     */
    public LoginException() {
    }

    /**
     *
     * @param message 表示异常提示
     */
    public LoginException(String message) {
        super(message);
    }
}
```

```java
public class Demo {
    // 模拟数据库中已存在账号
    private static String[] names = {"bill","hill","jill"};
   
    public static void main(String[] args) {     
        //调用方法
        try{
              // 可能出现异常的代码
            checkUsername("nill");
            System.out.println("注册成功");//如果没有异常就是注册成功
        }catch(LoginException e){
            //处理异常
            e.printStackTrace();
        }
    }

    //判断当前注册账号是否存在
    //因为是编译期异常，又想调用者去处理 所以声明该异常
    public static boolean checkUsername(String uname) throws LoginException{
        for (String name : names) {
            if(name.equals(uname)){//如果名字在这里面 就抛出登陆异常
                throw new LoginException("亲"+name+"已经被注册了！");
            }
        }
        return true;
    }
}
```


 ## 基本概念：程序、进程、线程
 ## 线程的创建和使用
 ### 方式一：继承与Thread类
 1. 创建一个继承与Thread类的子类
 2. 重写Thread类的run()方法
 3. 创建Thread类的子类对象
 4. 通过此对象调用start()


## 线程调度
线程的优先级：
  1. MAX_PRIORITY：10
  MIN _PRIORITY：1
 NORM_PRIORITY：5  -->默认优先级
2.如何获取和设置当前线程的优先级：
  getPriority():获取线程的优先级
 setPriority(int p):设置线程的优先级

说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。
## 方式二：实现Runnable接口
1. 创建一个实现了Runnable接口的类
2. 实现类去实现Runnable中的抽象方法：run()
3. 创建实现类的对象
 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
5. 通过Thread类的对象调用start()

比较创建线程的两种方式。
开发中：优先选择：实现Runnable接口的方式
原因：1. 实现的方式没有类的单继承性的局限性
    2. 实现的方式更适合来处理多个线程有共享数据的情况。

 联系：public class Thread implements Runnable
 相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。

 ## 线程的声明周期

                                           阻塞
 
新建--->就绪--->(获取CPU执行权)--->运行--->死亡


## 线程的同步

### 方法一：同步代码块
```
synchronized(同步监视器){
   //需要被同步的代码

}
```

>说明：1. 操作共享数据，即为需要被同步的代码
>2. 共享数据：多个线程共同操作的变量
>3. 同步监视器，俗称，锁。任意一个类的对象，都可以充当锁。
>     要求：多个线程必须共用同一把锁。
>     补充：在实现Runnable接口创建多线程的方式中，可以考虑使用this充当同步监视器。

同步的方式，解决了线程的安全问题。
操作同步代码时，只能有一个线程参与，其他线程等待，相当于一个单线程的过程，效率低。


### 方法二：同步方法
如果操作共享数据的代码完整的生命在一个方法中，可以同步方法。

关于同步方法的总结：
1. 同步方法仍然涉及到同步监视器，只是不需要我们显示的声明。
2. 非静态的同步方法，同步监视器是this
     静态的同步方法，同步监视器是当前类本身

### 死锁问题
 1. 死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步自愿，就形成了线程的死锁

### 方式三：Lock锁
JDK 5.0新增


### 线程的通信
`wait()` `notify()`

### 新增方式一：实现Callable接口

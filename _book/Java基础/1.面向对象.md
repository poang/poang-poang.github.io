# 面向对象

1. Java类及类的成员：属性、方法、构造器；代码块、内部类
2. 面向对象的三大特征：封装性、继承性、多态性
3. 其他关键字：this、super、static、final、abstract、interface、package、import

**面向过程（POP）和面向对象（OOP）**

1. 面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。
2. 面向对象：强调具备了功能的对象，以类、对象为最小单位，考虑谁来做。

面向对象的两个要素：
  1. 类：对一类事物的描述，是抽象的、概念上的定义
  2. 对象：是实际存在的该类事物的每个个体，因为也成为实例（instance）

- **面向对象程序设计的重点是类的设计**
- **设计类，就是设计类的成员**
  - 属性 = 成员变量 = field = 域、字段
  - 方法 =  成员方法 = 函数 = Method
- 类和对象的使用（面向对象思想落地实现）
  - 创建类，设计类的成员
  - 创建类的对象
  - 通过“对象.属性”或“对象.方法”调用对象的结构

**对象的内存解析**

虚拟机栈，及栈：**我们将局部变量存储在栈结构中**

堆：**我们将new出来的结构（比如：数组，对象）加载在堆空间中。**

 **补充：对象的属性（非static的）加载在堆空间中**		

方法区：**类的加载信息、常量池、静态域**

**匿名对象**

1. 理解：创建的对象，没有显示的赋给一个变量名。即为匿名对象
2. 特征：匿名对象只能调用一次

## 类中属性的使用



### 属性（成员变量） VS 局部变量

1. 相同点：
   - 定义变量的格式：数据类型  变量名 = 变量值
   - 先声明，后使用
   - 变量都有对应的作用域
2. 不同点
   - 在类中生命位置不同
     - 属性：直接定义在类的一对{}内
     - 局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
   - 关于权限修饰符的不同
     - 属性：可以在声明属性时，指明其权限，使用权限修饰符。
       常见的权限修饰符：private、public、缺省、protected
     - 局部变量：不允许使用权限修饰符
   - 默认初始化值的情况
     - 属性：类的属性，根据其类型，都有默认初始化值。
           整型（byte、short、int、long）  0
           浮点型（float、double）   0.0
           字符型（char） 0
           引用数据类型（类型、数组、接口）   null
     - 局部变量：没有默认初始化值，在调用局部变量之前，一定要显示赋值。
       特别的：形参在调用时赋值
   - 在内存中加载的位置：
     - 属性：加载到堆空间中
     - 局部变量：加载到栈空间中

## 类中方法的声明和使用

方法：描述类应该具有的功能

1. **方法的声明：**
    ```Java
	权限修饰符  返回值类型 方法明（形参列表）{
    
						方法体
    
	}
	```

2. 说明：
   - 关于权限修饰符：
     - 4种权限修饰符：private、public、缺省、protected
   - 返回值类型：有返回值、无返回值
     - 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中需要使用` return`返回指定类型的变量或常量；如果没有返回值，方法声明时，使用`void`表示
   - 方法名：属于标识符，遵循表示符的规则和规范
   - 形参列表：方法可以声明0个、1个或多个形参
     格式：数据类型1 形参1，数据类型2  形参2，...
   - 方法体：方法功能的体现
3. 方法的使用中，可以调用当前类的属性和方法

##  方法重载

1. 重载（overload）概念：在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数和参数类型不同即可。

   “两同一不同”：同一个类、相同方法名；参数列表不同：参数个数不同，参数列表不同

2. 判断是否重载：与方法的权限修饰符、返回值类型、形参变量名、方法体无关

3. 在通过对象调用方法时，如何确定某一个指定的方法：

   方法名------->参数列表

## 可变个数的形参

允许直接定义能和多个实参相匹配的形参，可以用更简单的方法，来传递个数可变的实参。

具体使用：

1. 格式：`数据类型 ... 变量名`
2. 调用可变个数形参时，传入参数个数可变
3. 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载
4. 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不够成重载
5. 可变个数形参在方法的形参中，必须声明在末尾
6. 可变个数形参在方法的形参中，最多只能声明一个可变形参

## 方法参数的值传递机制

### 变量赋值：

- 如果变量是基本数据类型，此时赋值的是变量所保存的数据值。
- 如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。

### 方法形参的传递机制：值传递

1. 形参:方法定义时，声明的小括号内的参数
   方法调用时，实际传递给形参的数据

2. 值传递机制：

   如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值

   如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值

## 面向对象特征之一：封装与隐藏

### 一、 问题引入：

当我们创建一个类的对象后，我们可以通过“对象.属性”的方法，对对象的属性进行赋值。赋值操作要受属性的数据类型和存储范围制约。不能在属性声明时体现，只能通过对方法进行限制条件的添加（如`setLegs()`方法）；同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值，需要将属性声明为私有的（`private`）

``` java
public class Animal{
    String name;
    int age;
    private int legs;
    public void setLeg(int l){
        if(l >= 0&& l%2 == 0){
            legs = l
        }else{
            legs = 0
        }
    }
}
```

### 二、封装性的体现

我们将类的属性xxx私有化（private），同时，提供公共的方法（public）来获取（get）和设置（set）

封装性的体现：1. 如上 2. 不对外暴露的私有方法 3. 单例模式

### 三、 权限修饰符

1. Java规定的四种权限：private、public、缺省、protected

   ![image-20220304123439061](http://poangspic.oss-cn-beijing.aliyuncs.com/img/image-20220304123439061.png)

2. 4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类
3. 修饰类是能用，缺省、public

 **构造器（构造方法）**

1. 构造器的作用：
   - 创建对象
   - 初始化信息
2. 说明：
   - 如果没有显示的定义构造器，系统提供一个空参构造器
   - 定义构造方法：`public 类名称（参数类型 参数名称）{}`
   - 一个类中定义的多个构造器，彼此构成重载
   - 显示定义了类的构造器，系统就不再提供默认的空参构造器
   - 一个类中至少会有一个构造器

## 关键字：this的使用

   this关键字的使用：

1. this可以用来修饰：属性、方法、构造器

2. this修饰属性和方法：

   this理解为：当前对象，即**通过谁调用的方法，谁就是this**
   `this.属性`

3. this修饰构造器

   - 我们在类的构造器中，可以显示的使用“this（形参列表）”的形式，调用本类中指定的其他构造器
   - 构造器中不能通过“this（参数列表）”方法调用自己 
   - this（参数列表）必须声明在当前构造器的首行
   - 构造器内部最多只能声明一个"this（参数列表）"用来调用其他构造器

 ## 面向对象特征之二：继承性

一、 继承性的好处：

1. 减少代码冗余，提高了代码复用性
2. 便于功能扩展
3. 位置后多态性使用，提供了前提



二、 继承性的格式：`class A extends B{}` 
 A:子类、派生类
 B：父类、超类、基类

1. 体现： 一旦子类A继承父类B后，子类A种就获取了父类B中声明的所有的属性和方法。
   特别的：父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的机构，只是因为封装性问题的影响，使得子类不能调用父类的结构
2. 子类继承以后，还可以声明自己特有的属性和方法：实现功能的拓展。

三、Java中关于继承性的规定：

1. 一个类可以被多个子类继承
2. 单继承性：一个类只能有一个父类
3. 子父类是相对的概念
4. 子类直接继承的父类，称为：直接父类；子类间接继承的父类：间接父类 
5. 子类继承父类以后，获取了直接父类以及间接父类中声明的属性和方法

四、 

1. 如果我们没有显示的声明一个类的父类的话，则此类继承于java.lang.Object类
2. 所有的Java类都直接或间接的继承java.lang.Object类

## 方法的重写
1. 重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作
2. 应用:重写以后，当创建子类对象后，通过子类对象调用子父类中的同名同参数方法是，实际执行的是子类重写父类的方法
3. 重写的规定：
	- 方法的声明： 权限修饰符 返回值类型 方法名（形参列表）{
	        // 方法体
		 }
	- 约定俗成：子类中的叫重写方法，父类中的叫被重写的方法
	- 子类和父类的的方法名和形参列表相同
	- 子类的方法权限修饰符不小于父类被重写的的方法的权限修饰符
	- 特殊形况:子类不能重写父类中声明为private
	- 返回值类型：
		- 父类被重写的方法返回值类型是void，则子类重写的方法返回值类型只能是void
		- 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A的子类
		- 父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型
		- 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型
		**子类和父类中同名同参数的方法要么都声明为非static的，要么都声明为static（不是重写）**
### super关键字
 1. super理解为：父类的
 2. super可以用来调用：属性、方法、构造器
 3. 使用：
	 - 在子类的方法或构造器中，使用`super.属性或 super.属性`的方式，显示的调用父类中声明的属性或方法。通常情况下,习惯省略`super.
	 - 特殊情况：当子类和父类中国定义了同名了同名的属性时，想要在子类中调用父类中声明的属性，则必须显示的使用`super.属性` 方法，表明调用的是父类中声明的属性
	 -  特殊情况：当子类重写了父类中的方法时，想要在子类的方法中父类中声明的方法，则必须显示的使用`super.方法` 调用的是父类中声明的方法

4. super调用构造器
	- 在子类的构造器中显示的使用`super(形参列表)`的方式，调用父类中声明的指定构造器
	- `super(形参列表)`的使用，必须声明在子类构造器的首行
	- 在类的构造器中，针对于`this(形参列表)`和`super(形参列表)`只能二选一，不能同时出现
	- 在构造器的首行，没有显示的声明`this(形参列表)`
	- 在类的多个构造器中，至少有一个构造器使用了`super(形参列表)`，调用父类中的构造器

**子类对象实例化的全过程** 
1. 从结果上来看：（继承性）
	子类继承父类后，就获取了父类中声明的属性或方法。
	创建子类的对象，在堆空间中，就会加载所有父类中声明的属性
2. 从过程来看：当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的构造器，直到调用了java.lang.Object类中空参的构造器。正因为加载过所有父类的结构，所以才可以看到内存中父类中的结构。

## 面向对象特征之三：多态性
1. 理解多态性： 可以理解为一个事物的多种形态。
2. 何为多态性
	- 对象的多态性：父类的引用指向子类的对象

3. 多态的使用：虚拟方法调用
	- 有了对象的多态性后，在编译期，只能调用父类中的声明的方法，在运行期，实际执行的是子类重写父类的方法
	- **总结：编译看左边，运行看右边**
4. 多态性的使用前提：
	1. 类的继承关系
	2. 方法的重写

5. 对象的多态性，只适用于方法，不适用于属性

**多态性是运行时行为**

## Object类中的属性和方法
Object类只声明了一个空参构造器

 ### equals
 **== 和equals() 的区别**
一 、 1. == 运算符，可以使用在基本数据类型变量和引用数据类型变量中
 2. 如果比较的是基本数据类型变量，比较两个变量保存的数值是否相等；
	如果比较的是引用数据类型变量：比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体

二、 equals（）方法的使用：
 1.  是一个方法，而非运算符
 2.  只能适用于引用数据类型
 3.  Object类中的equals()的定义：`pulbic boolean equals(Object obj)
    {
      return (this == obj);
      }`
  4. 重写，重写后比较的不是两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同

  ### toString方法

`public String toString()`:返回该对象的字符串表示。



toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。

由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。

```java
public class Person {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

## Objects类

Objects类是对象工具类，它里面的的方法都是用来操作对象的。

### equals方法

在**JDK7**添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。

在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：

* `public static boolean equals(Object a, Object b)`:判断两个对象是否相等。

```java
 public static boolean equals(Object a, Object b) {  
      return (a == b) || (a != null && a.equals(b));  
  }
```

### isNull

`static boolean isNull(Object obj)` 判断对象是否为null，如果为null返回true。

```java
Student s1 = null;
Student s2 = new Student("周杰伦", 22);

// static boolean isNull(Object obj) 判断对象是否为null,如果为null返回true
System.out.println(Objects.isNull(s1)); // true
System.out.println(Objects.isNull(s2)); // false
```


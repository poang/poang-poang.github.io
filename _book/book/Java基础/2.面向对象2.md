## 继承的设计技巧
1. 将公共操作和域放在超类
2. 不要使用受保护的域
3. 使用继承实现“is-a”关系
4. 除非所有继承的方法都有意义，否则不要使用继承
5. 在覆盖方法时，不要改变预期的行为
6. 使用多态，而非类型信息
7. 不要过多地使用反射


## 关键字：static
使用：
1. static:静态的
2. static可以用来修饰：属性，方法，代码块，内部类
3. static修饰属性：静态变量
	- 静态属性  vs 非静态属性
		- 实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性，当修改其中的一个对象的非静态属性时，不会导致其他对象中同样的属性值的修改
		- 静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当需改某一个对象改变静态变量时，会导致其他调用此静态变量时，变量被修改。
	- 其他说明：
		- 静态变量随着类的加载而加载，可以通过`类.静态变量`的方式调用
		- 静态变量的加载早于对象的创建。
		- 类只会加载一次，静态变量在内存中也只存在一份：存在方法区的静态域中。
	- 静态属性举例：System.out, Math.PI
4. static修饰方法：静态方法
	- 随着类的加载而加载，可以通过`类.方法`进行调用
	- 静态方法中，只能调用静态的方法或属性
5. static注意点：
	- 在静态方法内，不能使用this关键字、super关键字
	- 关于静态属性和静态方法的使用，从生命周期的角度理解
6. 如何确定一个属性是否要声明为static的？
     属性是可以被多个对象所共享的，不会随着对象的不同而不同。

     如何确定一个属性是否要声明为static的？
	操作静态属性的方法
	工具类中的方法，习惯上声明为static

## 设计模式单例（Singleton）
**设计模式**是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。

类的单例模式，就是采取一定的方法保证在整个软件系统中，对某个类**只能存在一个对象实例**，并且该类只提供一个取得其对象实例的方法。首先将类的构造器访问权限设置为private

### 单例模式优点：
由于单例模式只生成一个实例，减少系统性能开销。

### 单例模式-应用场景
网站计数器
应用程序的日志应用
数据库连接池



### 饿汉式单例模式

饿汉式：坏处：对象加载时间过长
			好处：是线程安全的

```java
pubilc class SingletonTest{
    public static void mian(String[] args){
        Bank bank1 = Bank.getInstance();
        Bank bank2 = Bank.getInstance();
        System.out.println(bank1 == bank2);
    }
}

class Bank(){
    //1.私有化类的构造器
    private Bank(){
        
    }
    //2.内部创建类的对象
    //4.要求此对象也声明为静态的
    private static Bank instance = new Bank();
    //3.提供公共的静态方法，返回类的对象
    public static Bank getInstance(){
        return instance;
    }
}
```



### 懒汉式单例模式（线程不安全）

懒汉式：好处：延迟对象的创建
			坏处：目前的写法，线程不安全

```Java
public class SingtonTest1{
    public static void main(String[] args){
        Order order1 = Order.getInstance();
        Order order2 = Order.getInstance();
        System.out.println(order1 == order2);
    }
}

class Order{
    private Order(){
        
    }
    private static Order instance = null;
    public static Order getInstance(){
        if(instance == null){
            instance = new Order();
        }
        return instance;
    }
}
```



## 代码块
1. 代码块作用：用于初始化类、对象
2. 代码块如果有修饰，只能用static
3. 分类：静态代码vs非静态代码块
4. 静态代码块
	- 内部可以有输出语句
	- 随着类的加载而执行，并且只执行一次
	- 作用：初始化类的信息
	- 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行
	- 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构
5. 非静态代码块
	- 内部可以有输出语句
	- 随着对象的创建而执行
	- 作用：可以在创建对象时，对对象的属性等进行初始化
	-  如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行
	- 非静态代码块可以调用静态的属性、静态的方法或非静态属性、非静态方法
## final关键字
1. 可以用来修饰的结构：类、方法、变量
2. 修饰类：此类不能被其他类所继承。比如：String类、System类、StringBuffer类
3. 修饰方法：此方法不能被重写。比如：Object类中的getClass();
4. 修饰变量：
     - 修饰属性，此时的变量为一个常量。
	 - 修饰局部变量，使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋值一个实参，之后只能在方法体内使用此形参，但不能重新赋值。
     `static final` 用来修饰属性：全局常量
## 抽象类与抽象方法
abstract关键字的使用
1. 抽象的
2. 可以用来修饰的结构：类、方法
3. 修饰类：抽象类
	- 此类不能实例化
	- 抽象类中一定有构造器，便于子类实例化时调用
4. 修饰方法：抽象方法
	- 抽象方法只有方法声明，没有方法体
	- 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法。
	- 若子类重写了父类中的所有抽象方法后，此子类可实例化
	若子类没有重写父类中的所有抽象方法，则此子类也是一个抽象类，需要使用abstract修饰

使用上的注意点：
 1. 不能用来修饰：属性、构造器等结构
 2. 不能用来修饰私有方法、静态方法、final

 ## 接口
 接口的使用：
 1. 用`interface` 来定义
 2. Java中，接口和类是并列的两个结构
 3. 如何定义接口：定义接口中的成员 
   -  全局常量：public static final的
   - 抽象方法：public abstract的
4. 接口中不能定义构造器，意味着口不可以实例化
5. 接口通过让类去实现（implements）的方式来使用 
    如果实现类覆盖了接口中的所有抽象方法，则此实现类可以实例化
	如果实现类没有覆盖接口中的所有抽象方法，不能实例化

6. Java类可以实现多个接口--->弥补了Java单继承的局限性
7. 接口与接口之间可以继承，而且可以多继承
8. 接口的具体使用，体现多态性
9. 接口，实际上可以看做是一种规范 

Java8中接口的新特性：
 除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法
 - 接口中定义的静态方法，只能通过接口来调用
 - 通过实现类的对象，可以调用接口中的默认方法
 - 如果子类（实现类）继承的父类和实现的接口中声明了同名同参数的方法，子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法
	
## 内部类
1. Java允许将一个类A声明在另一个类B中，则类A为内部类，类B为外部类
2. 内部类的分类：成员内部类 （静态、非静态） VS 局部内部类（方法内，代码块内、构造器内）
3. 成员内部类：
	 - 作为外部类的成员：
		 - 调用外部类的结构
		 - 可以被static修饰
		 - 可以被4中不同权限修饰
	- 作为一个类：
		- 类内可以定义属性、方法、构造器
		- 可以被final修饰，表示此类不能被继承
		- 可以被abstract修饰


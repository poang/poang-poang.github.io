# Java常用类
## 字符串类  
  String是一个`final` 修饰的类，体现不可变性
  String 对象的创建：1.字面量赋值 2.new+构造器   

  ### String 常用方法
  `int length()` :返回字符串长度
  `char charAt(int index)`：返回某索引字符
  `String trim()`:返回字符串副本，忽略首尾空格
  `boolean contains(CharSequence s)`：当且仅当此字符串包含指定的char值序列时，返回true
  `int indexof(String str)`:返回指定子字符串再此字符串中第一次出现的索引

### String与基本数据类型、包装类之间的转换
String-->基本上数据类型、包装类：调用包装类的静态方法： `parseXxx(str)`
基本上数据类型、包装类--->String:调用String重载的valueOf（xxx） 

### String与char[]之间的转换
String-->char[ ] :调用String的`toCharArray()` 
char-->String:调用String的构造器

## StringBuffer和StringBuilder
StringBuffer:可变的字符序列：线程安全，效率低；底层使用char[]
StringBuilder：可变的字符序列  线程不安全，效率高；底层使用char[]

### StringBuffer中常用的方法
`StringBuffer append()`:添加字符
`StringBuffer delete(int start,int end)`：删除指定位置的内容
`StringBuffer insert(int offset,xxx)`:在指定位置插入xxx
`StringBuffer replace(int start,int end,String str)`:替换
`StringBuffer reverse()`:反转

## JDK8之前日期时间API
`public static long currentTimeMillis()`:当前时间与1970年之间以毫秒为单位的时间差
### `java.util.Data`类
1. 两个构造器的使用
  - `Data()`
  - 创建指定毫秒数的Data对象 `Data(1213248948941L)`
2. 两个方法的使用
   -  `toString()`：显示当前的年月日时分秒
   - `getTime()`:获取当前时间的时间戳  

`java.text.SimpleDataFormat`类
对日期Date类的格式化和解析
1. 两个操作：
   - 格式化：日期-->字符串 `SimpleDateFormat`
   - 解析：字符串-->日期 `parse()`

`java.util.Calendar`日历（抽象类）
1. 实例化：
   - 创建其子类`GregrianCalendar`的对象
   - 创建其静态方法`getInstance()`


## JDK8中新日期时间API
`java.time`类
`LocalTime`
`LocalDate`

###  Instant的使用



## Java 比较器

1.说明：Java中的对象，正常情况下，只能进行比较：==  或  != 。不能使用 > 或 < 的
   但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。
  如何实现？使用两个接口中的任何一个：Comparable：自然排序 或 Comparator：定制排序

2.Comparable接口与Comparator的使用的对比：
   -  Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。
   - Comparator接口属于临时性的比较。

### 简述Comparable和Comparator两个接口的区别

**Comparable**：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。

**Comparator**：强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。

### 默认排序

```java
public class CollectionsDemo {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<Integer>();
   
        list.add(100);
        list.add(300);
        list.add(200);
        list.add(50);
        //排序方法 
        Collections.sort(list);
        System.out.println(list);
    }
}
```





### Comparator 定制排序代码示例

```java
public class CollectionsDemo {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<String>();
        list.add("cba");
        list.add("aba");
        list.add("sba");
        list.add("nba");
        //排序方法  按照第一个单词的降序
        Collections.sort(list, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o2.charAt(0) - o1.charAt(0);
            }
        });
        System.out.println(list);
    }
}
```




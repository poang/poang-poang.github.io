# 刷题进度
## 题目类型：
- [ ] 数组
- [x] 链表
- [ ] 哈希表
- [ ] 字符串
- [ ] 栈与队列
- [ ] 二叉树
- [ ] 回溯算法
- [ ] 贪心算法
- [ ] 动态规划
- [ ] 单调栈

## 题目及描述：

题目：[02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)
描述：给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。
图示两个链表在节点 `c1` 开始相交：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

示例1：![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)

> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
> 输出：Intersected at '8'
> 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
> 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
> 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点

示例2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png)

> 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
> 输出：Intersected at '2'
> 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
> 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
> 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

思路：首先找到两个链表的的长度，然后让长链表移动差值个位置，使两个链表尾对齐，然后同时移动链表，判断节点是否相等。




## 代码：
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        int sizeA = 0;
        int sizeB = 0;
        ListNode dummyA = headA;
        ListNode dymmyB = headB;
        
        while(dummyA != null){
            dummyA = dummyA.next;
            sizeA++;
        }
        while(dymmyB != null){
            dymmyB = dymmyB.next;
            sizeB++;
        }
        if (sizeA <= sizeB){
            int step = sizeB - sizeA;
            while(step-- > 0){
                headB = headB.next;
            }
        }else{
            int step =sizeA - sizeB;
            while(step-- > 0){
                headA = headA.next;
            }
        }
     
        while(headA != null){
             if(headA == headB){
                return headA;
            }else{
                headA = headA.next;
                headB = headB.next;
            }
        }
        return null;
    }
}
```




## 总结：

题是简单题，很容易想到解题思路，但是还是写代码还是考虑不全，不能做到bug free。
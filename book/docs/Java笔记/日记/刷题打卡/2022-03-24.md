# 刷题进度
## 题目类型：
- [ ] 数组
- [x] 链表
- [ ] 哈希表
- [ ] 字符串
- [ ] 栈与队列
- [ ] 二叉树
- [ ] 回溯算法
- [ ] 贪心算法
- [ ] 动态规划
- [ ] 单调栈

## 题目及描述：

题目：[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
描述：给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表

示例1：![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

> ```
> 输入：head = [1,2,3,4,5]
> 输出：[5,4,3,2,1]
> ```



思路：链表原地反转，使用一个临时节点保存cur的下一个节点的信息，因为需要将当前节点的下一节点指向pre，当cur不为null时，重复之前操作。

## 代码：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
// 普通版本
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        ListNode temp = null;
        while(cur != null){
            temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```

```java 
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
//递归
class Solution {
    public ListNode reverseList(ListNode head) {
       ListNode pre = null;
       return reverse(pre,head);
    }

      private ListNode reverse(ListNode pre,ListNode cur) {
       if (cur == null){
           return pre;
       }
       ListNode temp = null;
       temp = cur.next;
       cur.next = pre;

       return reverse(cur,temp);
    }
    
}
```




## 总结：
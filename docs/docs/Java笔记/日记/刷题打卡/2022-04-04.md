# 刷题进度
## 题目类型：
- [ ] 数组
- [ ] 链表
- [x] 哈希表
- [ ] 字符串
- [ ] 栈与队列
- [ ] 二叉树
- [ ] 回溯算法
- [ ] 贪心算法
- [ ] 动态规划
- [ ] 单调栈

## 题目及描述：

### 题目：[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)
描述：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。



思考：暴力解就是双for循环对比，时间复杂度为O（$n^2$）。本题要同时记录值和索引，可以考虑使用map，利用键值对的方式存储值和索引。




## 代码：
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int [] res = new int[2];
        if (nums == null || nums.length == 0){
            return null;
        }
        Map<Integer,Integer> map = new HashMap();
        for (int i = 0; i <nums.length; i++){
            int temp = target - nums[i];
            if(map.containsKey(temp)){
                //题意可以按任意顺序返回
                res[0] = i;  
                res[1] = map.get(temp);
            }
            map.put(nums[i],i);
        }
        return res;
    }
}
```

## 题目及描述：

### 题目：[454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

描述：给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：

- 0 <= i, j, k, l < n
- nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0

示例1： 

> 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
> 输出：2
> 解释：
> 两个元组如下：
> 1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
> 2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
>

思考：四数相加，两数之和升级版。首先先遍历前两个数组，统计相加之和，和出现字数，并存入到数组中；然后遍历后两个数组时，设定count ，判断总和0-(a+b)是否存在于map中，若存在，统计出现次数。



## 代码：

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map<Integer,Integer> map = new HashMap<>();
        int count = 0;
        for (int i : nums1){
            for (int j : nums2){
                int temp = i + j;
                if (map.containsKey(temp)){
                    map.put(temp,map.get(temp)+1);
                }else{
                    map.put(temp,1);
                }
            }
        }
        for(int i : nums3){
            for (int j : nums4){
                int temp = i + j;
                if(map.containsKey(0 - temp)){
                    count += map.get(0 -temp);
                }
            }
        }
        return count;
    }
}
```




## 总结：

数组问题，和、索引。使用哈希法的特点。

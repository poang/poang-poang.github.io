# 刷题进度
## 题目类型：
- [x] 数组
- [ ] 链表
- [ ] 哈希表
- [ ] 字符串
- [ ] 栈与队列
- [ ] 二叉树
- [ ] 回溯算法
- [ ] 贪心算法
- [ ] 动态规划
- [ ] 单调栈

## 题目及描述：
**题目**：704.[二分查找](https://leetcode-cn.com/problems/binary-search/ )
**描述**： 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。


### 思路
 元素有序且假定元素唯一，考虑二分查找。
 实际编写代码时，考虑二分查找的边界条件。一般区间定义有两种，左闭右闭[left,right],左闭右开[left,right)，两者区别在于跳出循环的判断条件和查找边界划分。
 ### 左闭右闭

- `while(left <= right)`要使用<=,因为left == right是有意义的
- `if(nums[middle] > target)`right的值要为middle-1,因为nums[middle]这个值一定不是target，右区间设置为middle-1；同理，`if(nums[middle] < target)`left赋值为middle+1

### 左闭右开

- `while(left <=right)`要使用<,因为右值取不到，left == right是没有意义的
- `if(nums[middle] > target)`right的值要为middle,因为nums[middle]这个值一定不是target，右区间设置为middle；而`if(nums[middle] < target)`left赋值为middle+1，因为此时的nums[middle]一定不为target

## 代码：
```java 
class Solution {
    public int search(int[] nums, int target) {
        // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算
        if (target < nums[0] || target > nums[nums.length - 1]) {
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;
    }
}

```

## 总结：

按推荐刷题的第一道，二分查找的想法可以想到，一看就会，一写就废。主要就是实际编写代码没有考虑到二分查找的边界问题。


## 相关题目
[35.搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)
[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
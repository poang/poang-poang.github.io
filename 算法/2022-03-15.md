# 刷题进度
## 题目类型：
- [x] 数组
- [ ] 链表
- [ ] 哈希表
- [ ] 字符串
- [ ] 栈与队列
- [ ] 二叉树
- [ ] 回溯算法
- [ ] 贪心算法
- [ ] 动态规划
- [ ] 单调栈

## 题目及描述：

题目： [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)
描述：给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**进阶：**

-   请你设计时间复杂度为 `O(n)` 的算法解决本问题


思路： 如果暴力解就是顺序计算平方，然后进行排序，时间复杂度为$O(n+ nlogn)$

进阶要求时间复杂度为O(n)，需要在一个循环中进行，并且可以创建新的数组用来保存。因为存在负数，平方后可能会大于正数的平方，影响计算平方后的排序，因此可以在遍历的时候比较两侧平方的结果，将比较的大值或小值按顺序存放到新的数组中。
用双指针法，新建一个数组，并将 数组索引指针`index`指到末尾，判断左右指针索引对应的平方结果，如果右指针的平方大于左指针的平方，将右指针放入到数组的末尾，数组指针`index--`，右指针`right--`；反之将左指针结果放入数组末尾，左指针`left++`
1. 循环结束的标志，`while(left <= right)`相等是有意义的
2. 如果数组插入顺序改变，判断条件也要改变


## 代码：
```java
class Solution {

 public int[] sortedSquares(int[] nums) {

 int left = 0;

 int right = nums.length - 1;

 int index = nums.length - 1;

 int[] result = new int[nums.length];

 while(left <= right){

 if (nums[left] * nums[left] < nums[right] * nums[right]){

 result[index--] = nums[right] * nums[right];

 right--;

 }else{

 result[index--] = nums[left] * nums[left];

 left++;

 }

 }

 return result;

  

 }

}
```




## 总结：
双指针，注意指针的移动情况和判断边界情况。